E(Includes/global)
E(Includes/point_include)

layout(std430, binding = 2) buffer point_compute_ssbo
{
	PointLight lights[];
};


#define MAX_LIGHTS 1024
#define GROUP_SIZE 16


uniform uint nrOfLights;

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;
layout(rgba8, binding = 0) uniform image2D main_tex;

shared uint minDepth;
shared uint maxDepth;
shared int finalLightsIndices[MAX_LIGHTS];	//Keeps track of the indices of lights to be rendered
shared int finalLightsNr = 0;				//Counter for lights that are not culled

void sync();
void getMinMaxDepth(sampler2D t, ivec2 coords);
bool intersectPlane(vec3 origin, vec3 normal, PointLight pl);
bool planeSide(vec3 pos, vec4 plane);
bool planeIntersect(vec3 pos, float rad, vec4 plane);

void main() {

	if (gl_LocalInvocationID.x + gl_LocalInvocationID.y == 0) {
		atomicExchange(maxDepth, 0);
		atomicExchange(minDepth, 0xFFFFFFFFu);
		atomicExchange(finalLightsNr, 0);
	}
	sync();

	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	vec3 color = vec3(0, 0, 0);
	
	getMinMaxDepth(depth_tex, coords);
	sync();

	float left = float(gl_WorkGroupID.x * GROUP_SIZE);
	float right = float(gl_WorkGroupID.x * (GROUP_SIZE+1));
	float bottom = float(gl_WorkGroupID.y * GROUP_SIZE);
	float top = float(gl_WorkGroupID.y * (GROUP_SIZE + 1));

	left = (left / screen_width) * 2 - 1;
	right = (right / screen_width) * 2 - 1;
	bottom = (bottom / screen_height) * 2 - 1;
	top = (top / screen_height) * 2 - 1;

	float depth_near = (float(minDepth) / 0xFFFFFFFFu) * 2 - 1;
	float depth_far = (float(maxDepth) / 0xFFFFFFFFu) * 2 -1;

	vec3 LB = (iP * vec4(left, bottom, 1,1)).xyz;
	vec3 LT = (iP * vec4(left, top, 1,1)).xyz;
	vec3 RB = (iP * vec4(right, bottom, 1,1)).xyz;
	vec3 RT = (iP * vec4(right, top, 1,1)).xyz;
	vec4 _DepthN = iP * vec4(0, 0, depth_near, 1);
	vec4 _DepthF = iP * vec4(0, 0, depth_far, 1);
	vec3 DepthN = _DepthN.xyz / _DepthN.w;
	vec3 DepthF = _DepthF.xyz / _DepthF.w;

	vec4 planeL = vec4(normalize(cross(LT, LB)),0);
	vec4 planeT = vec4(normalize(cross(RT, LT)),0);
	vec4 planeR = vec4(normalize(cross(RB, RT)),0);
	vec4 planeB = vec4(normalize(cross(LB, RB)),0);
	vec4 planeDepthN = vec4(0, 0, 1, 0);
	vec4 planeDepthF = vec4(0, 0, -1, 0);

	planeL = vec4(planeL.xyz, -dot(LB, planeL.xyz));
	planeT = vec4(planeT.xyz, -dot(LT, planeT.xyz));
	planeR = vec4(planeR.xyz, -dot(RT, planeR.xyz));
	planeB = vec4(planeB.xyz, -dot(RB, planeB.xyz));
	planeDepthN = vec4(planeDepthN.xyz, -dot(DepthN, planeDepthN.xyz));
	planeDepthF = vec4(planeDepthF.xyz, -dot(DepthF, planeDepthF.xyz));

	for (int i = 0; i < nrOfLights; i++) {

		vec3 pos = (V * lights[i].position).xyz;
		float rad = lights[i].radius;

		bool centerL = planeSide(pos, planeL);
		bool centerR = planeSide(pos, planeR);
		bool centerT = planeSide(pos, planeT);
		bool centerB = planeSide(pos, planeB);
		bool centerDN = planeSide(pos, planeDepthN);
		bool centerDF = planeSide(pos, planeDepthF);

		bool faceL = planeIntersect(pos, rad, planeL);
		bool faceR = planeIntersect(pos, rad, planeR);
		bool faceT = planeIntersect(pos, rad, planeT);
		bool faceB = planeIntersect(pos, rad, planeB);
		bool faceDN = planeIntersect(pos, rad, planeDepthN);
		bool faceDF = planeIntersect(pos, rad, planeDepthF);


		bool insideW = centerL && centerR;
		bool insideH = centerT && centerB;
		bool insideD = centerDN && centerDF;

		bool inside = insideW || faceL || faceR;			//Inside horizontal planes
		inside = inside && (insideH || faceT || faceB);		//Inside vertical planes
		inside = inside && (insideD || faceDF || faceDN);	//Inside depth planes


		color += vec3(1, 1, 1) * (inside ? .1 : 0);	//0.1 * get_shaded_fragment(lights[i], coords);
	}




	for (int i = 0; i < nrOfLights; i++) {
		color +=  get_shaded_fragment(lights[i], coords);
	}

	imageStore(main_tex, coords, vec4(color, 1));
}

float get_shadow(vec3 light_world_dir, float fov) {
	return 1;
}

void sync() {
	groupMemoryBarrier();
	barrier();
}

void getMinMaxDepth(sampler2D t, ivec2 coords) {
	float fdepth = texelFetch(t, coords, 0).r;
	uint depth = uint(fdepth * 0xFFFFFFFFu);
	atomicMin(minDepth, depth);
	atomicMax(maxDepth, depth);
}


bool planeSide(vec3 pos, vec4 plane) {
	return dot(pos, plane.xyz) < -plane.w;
}

bool planeIntersect(vec3 pos, float rad, vec4 plane) {
	return abs(dot(pos, plane.xyz) +plane.w) < + rad;
}




