E(Includes/global)
E(Includes/point_include)

layout(std430, binding = 2) readonly buffer point_compute_ssbo
{
	PointLight lights[];
};


#define MAX_LIGHTS 512
#define GROUP_SIZE 16


uniform uint nrOfLights;

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;
layout(rgba8, binding = 0) uniform image2D main_tex;

shared uint minDepth;
shared uint maxDepth;
shared uint finalLightsIndices[MAX_LIGHTS];	//Keeps track of the indices of lights to be rendered
shared uint finalLightsNr = 0;				//Counter for lights that are not culled

void sync();
void getMinMaxDepth(sampler2D t, ivec2 coords);
bool insidePlanes(vec3 pos, float rad, vec4 planeA, vec4 planeB);
bool insideDepth(float z, float rad, float n, float f);

void main() {

	if (gl_LocalInvocationID.x + gl_LocalInvocationID.y == 0) {
		atomicExchange(maxDepth, 0);
		atomicExchange(minDepth, 0xFFFFFFFFu);
		atomicExchange(finalLightsNr, 0);
	}
	sync();

	const ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
	vec3 color = vec3(0, 0, 0);
	
	getMinMaxDepth(depth_tex, coords);
	sync();

	const float left = (float(gl_WorkGroupID.x * GROUP_SIZE) / screen_width) * 2 - 1;
	const float right = (float((gl_WorkGroupID.x+1) * GROUP_SIZE) / screen_width) * 2 - 1;
	const float bottom = (float(gl_WorkGroupID.y * GROUP_SIZE) / screen_height) * 2 - 1;
	const float top = (float((gl_WorkGroupID.y+1) * GROUP_SIZE) / screen_height) * 2 - 1;

	const float depth_near = (float(minDepth) / 0xFFFFFFFFu) * 2 - 1;
	const float depth_far = (float(maxDepth) / 0xFFFFFFFFu) * 2 -1;

	const vec3 LB = (iP * vec4(left, bottom, 1,1)).xyz;
	const vec3 LT = (iP * vec4(left, top, 1,1)).xyz;
	const vec3 RB = (iP * vec4(right, bottom, 1,1)).xyz;
	const vec3 RT = (iP * vec4(right, top, 1,1)).xyz;
	const vec4 _DepthN = iP * vec4(0, 0, depth_near, 1);
	const vec4 _DepthF = iP * vec4(0, 0, depth_far, 1);
	const vec3 DepthN = _DepthN.xyz / _DepthN.w;
	const vec3 DepthF = _DepthF.xyz / _DepthF.w;

	vec4 planeL = vec4(normalize(cross(LT, LB)),0);
	vec4 planeT = vec4(normalize(cross(RT, LT)),0);
	vec4 planeR = vec4(normalize(cross(RB, RT)),0);
	vec4 planeB = vec4(normalize(cross(LB, RB)),0);
	vec4 planeN = vec4(0, 0, 1, 0);
	vec4 planeF = vec4(0, 0, -1, 0);

	planeL = vec4(planeL.xyz, -dot(LB, planeL.xyz));
	planeT = vec4(planeT.xyz, -dot(LT, planeT.xyz));
	planeR = vec4(planeR.xyz, -dot(RT, planeR.xyz));
	planeB = vec4(planeB.xyz, -dot(RB, planeB.xyz));
	planeN = vec4(planeN.xyz, -dot(DepthN, planeN.xyz));
	planeF = vec4(planeF.xyz, -dot(DepthF, planeF.xyz));

	const uint local_offset = GROUP_SIZE * gl_LocalInvocationID.x + gl_LocalInvocationID.y;
	const uint sqr_size = GROUP_SIZE*GROUP_SIZE;

	for (uint i = local_offset; i < nrOfLights; i+= sqr_size) {
		
		const PointLight p = lights[i];
		const vec3 pos = (V * p.position).xyz;
		const float rad = p.radius;
	
		const bool insideX = insidePlanes(pos, rad, planeL, planeR);
		const bool insideY = insidePlanes(pos, rad, planeT, planeB);
		const bool insideZ = insideDepth(pos.z, rad, DepthN.z, DepthF.z);


		const bool inside = insideX && insideY && insideZ;			//Inside horizontal planes
		if (inside) {
			const uint idx = atomicAdd(finalLightsNr, 1);
			finalLightsIndices[idx] = i;
			color = maxDepth * vec3(1, 1, 1);
		}
		
	}

	sync();

	const MatInfo info = extract_info_from_gbuffer(coords);

	for (int i = 0; i < finalLightsNr; i++) {
		color += get_shaded_fragment(lights[finalLightsIndices[i]], info);
	}

	imageStore(main_tex, coords, vec4(clean_color(color), 1));
}

float get_shadow(vec3 light_world_dir, float fov) {
	return 1;
}

void sync() {
	groupMemoryBarrier();
	barrier();
}

void getMinMaxDepth(sampler2D t, ivec2 coords) {
	float fdepth = texelFetch(t, coords, 0).r;
	uint depth = uint(fdepth * 0xFFFFFFFFu);
	atomicMin(minDepth, depth);
	atomicMax(maxDepth, depth);
}


bool insidePlanes(vec3 pos, float rad, vec4 planeA, vec4 planeB) {
	float dotA = dot(pos, planeA.xyz) + planeA.w;
	float dotB = dot(pos, planeB.xyz) + planeB.w;
	float sqrRad = rad*rad;
	return (dotA<0 && dotB <0) || (dotA*dotA < sqrRad) || (dotB*dotB < sqrRad);
}

bool insideDepth(float z, float rad, float f, float n) {
	return (z > n - rad && z < f + rad);
}






