//4-byte aligned
struct SpotLight {
	uint diffuse;
	uint specular;
	float diffuse_intensity;
	float specular_intensity;
	vec4 position; 
	vec4 direction;
	float cutoff; float attenuation; uint blur; float shininess;
};

uniform sampler2D diffuse_tex;
uniform sampler2D specular_tex;
uniform sampler2D normal_tex;
uniform sampler2D depth_tex;


float get_shadow(vec3 position_world_space, float dotNL);

vec3 get_shaded_fragment(SpotLight spot_light, ivec2 coords) {

	//Rebuild position from depth
	float depth = (1-texelFetch(depth_tex, coords, 0).r) *2.0 - 1.0;
	vec2 ndc_coords = (vec2(coords) / vec2(screen_width, screen_height))* 2.0 - 1.0;
	vec4 position_screen_space = vec4(ndc_coords, depth, 1);
	vec4 position_view_space_not_normalized = iP * position_screen_space;
	vec3 position_view_space = position_view_space_not_normalized.xyz / position_view_space_not_normalized.w;
	vec4 position_world_space_not_normalized = iVP * position_screen_space;
	vec3 position_world_space = position_world_space_not_normalized.xyz / position_world_space_not_normalized.w;



	//Color directly from g buffer
	vec4 sample_diff = texelFetch(diffuse_tex, coords, 0);
	vec3 mat_diff = sample_diff.rgb;
	float flatness = sample_diff.w;
	vec4 sample_spec = texelFetch(specular_tex, coords, 0);
	vec3 mat_spec = sample_spec.rgb;
	float mat_spec_pow = sample_spec.w;

	//Normal z-axis built back from the other two
	vec2 n = texelFetch(normal_tex, coords, 0).xy * 2.0 - 1;
	vec3 normal_view_space = vec3(n.x, n.y, sqrt(1 - dot(n.xy, n.xy)));

	//Important vectors
	vec4 light_dir_world_space_not_normalized = spot_light.position - vec4(position_world_space, 1);
	vec4 light_dir_world_space = normalize(light_dir_world_space_not_normalized);
	vec4 light_dir_view_space = itV * light_dir_world_space;
	vec4 view_dir_view_space = vec4(normalize(-position_view_space), 0);
	vec4 half_dir_view_space = vec4(normalize(light_dir_view_space.xyz + view_dir_view_space.xyz), 0);

	//Calculate attenuation
	float distance = length(light_dir_world_space_not_normalized.xyz);
	float attenuation = 1+pow(distance, spot_light.attenuation);

	//Calculate base colors
	vec3 diff_color = split3(spot_light.diffuse) * spot_light.diffuse_intensity;
	vec3 spec_color = split3(spot_light.specular) * mat_spec_pow * spot_light.specular_intensity;


	//final colors for diffuse and specular
	float dotNL = dot(normal_view_space, light_dir_view_space.xyz);
	vec3 diffuse_final = max(0, dotNL) * diff_color;
	vec3 specular_final = spec_color * pow(max(dot(half_dir_view_space.xyz, normal_view_space), 0.000001), spot_light.shininess);


	//CONE CUTOFF (with smoothing to the edges)
	float actual_cutoff = dot(normalize(position_world_space - spot_light.position.xyz), spot_light.direction.rgb);

	actual_cutoff = clamp(mix(0, 1, (actual_cutoff - spot_light.cutoff) / (spot_light.cutoff * 0.1)), 0.0, 1.0);


	//fragment color
	vec3 final_color = flatness * mat_diff + actual_cutoff * get_shadow(position_world_space, dotNL) *  (1.0 - flatness) * (mat_spec * specular_final + mat_diff * diffuse_final) / attenuation;
	return clean_color(final_color);
}


